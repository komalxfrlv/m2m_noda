generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model City {
  id    String @id @unique @default(uuid())
  name  String @db.VarChar(99)
  users User[]
}

model User {
  id             String             @id @unique @default(uuid())
  name           String             @db.VarChar(255)
  surname        String             @db.VarChar(255)
  patronymic     String             @db.VarChar(255)
  email          String             @unique
  password       String
  auto_updating  Boolean            @default(true)
  auto_paying    Boolean            @default(true)
  hash_rst       String?            @db.VarChar(255)
  remainingTries Int                @default(0)
  verified       Boolean            @default(false)
  hash_vrf       String?            @db.VarChar(255)
  token          String?
  phone          BigInt
  status         UserStatus
  client         UserClient
  role           UserRole
  cityId         String
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  metrics        Metric[]
  refreshTokens  RefreshToken[]
  shelldues      Shelldue[]
  stations       Station[]
  city           City               @relation(fields: [cityId], references: [id])
  userGroups     UserToUserGroups[]
}

model RefreshToken {
  id          String   @id @unique @default(uuid())
  hashedToken String
  userId      String
  revoked     Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model DeviceType {
  id         String    @id @unique @default(uuid())
  name       String    @db.VarChar(255)
  sensors    Sensor[]
  stations   Station[]
  versions   Version[]
}

model Version {
  id          String            @id @unique @default(uuid())
  fileUrl     String
  description String
  version     String            @db.VarChar(255)
  deviceId    String
  servFileUrl String            @default("")
  sensors     SensorSettings[]
  stations    StationSettings[]
  device      DeviceType        @relation(fields: [deviceId], references: [id])
}

model Station {
  id        String                @id @unique @default(uuid())
  mac       String                @db.VarChar(99)
  userId    String
  deviceId  String
  sensors   Sensor[]
  device    DeviceType            @relation(fields: [deviceId], references: [id])
  user      User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  settings  StationSettings?
  shelldues ShellduesOnStations[]
}

model StationSettings {
  id        String  @id @unique @default(uuid())
  name      String  @db.VarChar(255)
  stationId String  @unique
  versionId String
  options   Json?
  station   Station @relation(fields: [stationId], references: [id], onDelete: Cascade)
  version   Version @relation(fields: [versionId], references: [id])
}

model Sensor {
  id        String          @id @unique @default(uuid())
  mac       String          @db.VarChar(99)
  uptime    BigInt?
  charge    Int?            @db.SmallInt
  deviceId  String
  stationId String
  data      Data[]
  device    DeviceType      @relation(fields: [deviceId], references: [id])
  station   Station         @relation(fields: [stationId], references: [id], onDelete: Cascade)
  settings  SensorSettings?
}

model SensorSettings {
  id         String    @id @unique @default(uuid())
  name       String    @db.VarChar(255)
  sleep      BigInt?   @default(10)
  alert      Boolean   @default(false)
  lost       Boolean   @default(false)
  sensorId   String    @unique
  versionId  String
  pushStart  DateTime? @db.Time(6)
  pushEnd    DateTime? @db.Time(6)
  triggerMin Float?
  triggerMax Float?
  schedule   Json?
  options    Json?
  sensor     Sensor    @relation(fields: [sensorId], references: [id], onDelete: Cascade)
  version    Version   @relation(fields: [versionId], references: [id])
}

model Data {
  id        String   @id @unique @default(uuid())
  value     Json
  sensorId  String
  createdAt DateTime @default(now())
  sensor    Sensor   @relation(fields: [sensorId], references: [id], onDelete: Cascade)
}

model Activity {
  id     String   @id @unique @default(uuid())
  name   String
  metric Metric[]
}

model Metric {
  id         String   @id @unique @default(uuid())
  activityId String
  datetime   DateTime @default(now())
  userId     String
  activity   Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserGroups {
  id         String             @id @unique @default(uuid())
  name       String
  pushGroups UserToUserGroups[]
}

model UserToUserGroups {
  userGroupId String
  userId      String
  userGroup   UserGroups @relation(fields: [userGroupId], references: [id], onDelete: Cascade)
  user        User       @relation(fields: [userId], references: [id])

  @@id([userGroupId, userId])
}

model Shelldue {
  id             String                   @id @unique @default(uuid())
  active         Boolean
  name           String
  hash           String?
  shelldueScript Json
  userId         String
  deviceTypes    String[]
  stations       ShellduesOnStations[]
  user           User                     @relation(fields: [userId], references: [id])
}

model ShellduesOnStations {
  id         String   @id @unique @default(uuid())
  shelldue   Shelldue @relation(fields: [shelldueId], references: [id])
  shelldueId String
  station    Station  @relation(fields: [stationId], references: [id])
  stationId  String
}

enum UserStatus {
  active
  inactive
}

enum UserClient {
  bussiness
  person
  local
}

enum UserRole {
  administrator
  developer
  manager
  support
  user
}
